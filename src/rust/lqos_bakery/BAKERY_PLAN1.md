# LQOS Bakery - Phase 1 Implementation Plan

## Overview
Phase 1 goal: Mirror the existing LibreQoS.py TC (Traffic Control) functionality in Rust, maintaining exact behavioral compatibility while keeping all logic in Python.

## Immediate Tasks

### 1. Verify and Update Helper Functions
- [ ] Review `r2q_bandwidth()` function - verify it matches Python's `r2q()`
  - **Finding**: Python's `calculateR2q()` IS still used (line 883 in LibreQoS.py)
  - **Issue**: Python sets a global R2Q variable used by quantum(), Rust calculates but doesn't use it
- [ ] Review `quantum()` function - verify it matches Python's `quantum()`
  - **Bug Found**: Rust hardcodes division by 8, Python uses dynamically calculated R2Q
  - **Fix Needed**: Rust quantum() should use the calculated r2q value, not hardcoded 8
- [ ] Update both functions to support fractional speeds (building on previous fractional speeds work)
- [ ] **Create unit tests** to verify Rust matches Python exactly:
  - Test `r2q_bandwidth()` with various bandwidth values (1, 10, 100, 1000, 10000 Mbps)
  - Test `quantum()` with the same range of values
  - Include fractional speed tests (1.5, 10.5, 999.9 Mbps)
  - Compare outputs with Python-calculated expected values

### 2. Fractional Speed Formatting
- [ ] Create helper function to format bandwidth values with appropriate units (Mbit, Kbit, etc.)
- [ ] Match Python's formatting behavior exactly (see `format_rate_for_tc()` at line 81)
  - Rates ≥ 1000 Mbps → "X.Xgbit" (1 decimal place)
  - Rates ≥ 1 Mbps → "X.Xmbit" (1 decimal place)
  - Rates < 1 Mbps → "Xkbit" (0 decimal places)
- [ ] Support fractional values (e.g., 1.5Mbit, 500.5Kbit)
- [ ] Create unit tests for format_rate_for_tc() with edge cases

### 3. TC Command Mirroring
- [ ] Identify all locations in LibreQoS.py where TC commands are executed
- [ ] Create Rust equivalents for each TC operation type:
  - [ ] Queue creation (qdisc add/replace/delete)
  - [ ] Class creation (class add/change/delete)
  - [ ] Filter operations (if any)
  - [ ] Queue statistics queries
- [ ] Ensure all TC command builders support fractional speeds

### 4. Centralized TC Command Execution
- [ ] Create a single function to handle all TC command execution
- [ ] Add compile-time constant `WRITE_TC_TO_FILE` to control behavior
- [ ] When `WRITE_TC_TO_FILE` is true:
  - Append commands to `tc-rust.txt` (similar to Python's `linux_tc.txt`)
  - Format: Just the TC arguments (no `/sbin/tc` prefix), one per line
  - Match Python's format exactly for easy comparison
- [ ] When `WRITE_TC_TO_FILE` is false:
  - Execute commands via `std::process::Command`
  - Handle errors appropriately
- [ ] Update all existing TC command calls to use this function
- [ ] Consider batching commands like Python does (using `tc -b` with file)
- [ ] This enables comparison testing between Python and Rust outputs

### 5. Python Integration Points
- [ ] Add comments to LibreQoS.py indicating future Rust API call locations
- [ ] Document the expected API interface for each call
- [ ] Do NOT implement actual calls - just mark the locations

## TC Command Categories to Mirror

### Queue Management
- MQ (Multi-Queue) setup ✓ (partially done)
- HTB hierarchy creation ✓ (partially done)
- CAKE qdisc configuration
- FQ-CoDel qdisc configuration (if used)

### Class Management
- Root classes
- Circuit classes
- Default classes
- Class modifications (bandwidth changes)

### Additional Operations
- Queue deletion/cleanup
- Statistics gathering
- Error handling patterns

## Design Principles
1. **Exact Behavioral Match**: Every TC command generated by Rust must match Python's output exactly
2. **No Logic in Rust**: All decision-making remains in Python; Rust only executes TC commands
3. **Fractional Speed Support**: All bandwidth specifications must support fractional values
4. **Error Handling**: Mirror Python's error handling behavior

## Next Steps After Phase 1
- Phase 2: Lazy queue creation (only create when traffic detected)
- Phase 3: Differential updates (track changes, apply only deltas)
- Phase 4: Live migration (lossless queue movement)

## Python Bugs Found During Analysis

### 1. **`sqmFixupRate()` function incompatible with fractional speeds** (line 927)
   - Type hint still expects `int` for rate parameter
   - `match` statement uses exact equality, won't match fractional rates like 1.5
   - CAKE RTT adjustments for low bandwidth won't apply to fractional speed circuits
   - Needs to be updated to handle rate ranges instead of exact matches

### 2. **Integer conversions losing fractional precision**
   - **Lines 397-400**: Circuit bandwidth comparisons convert to `int()`, losing fractional parts
   - **Lines 642-645**: `inheritBandwidthMaxes()` converts all bandwidth values to integers
   - These conversions will cause fractional speeds to be truncated

### 3. **Exact equality checks on float values**
   - **Lines 960-963**: Checks like `if min_down == 1:` may fail with floating-point values
   - Should use approximate comparisons or ranges

### 4. **Rounding without decimal specification**
   - **Lines 894, 915**: `round()` without decimals parameter rounds to nearest integer
   - Should specify decimal places to preserve fractional values where needed

### 5. **Good news**: Most of the codebase already handles fractional speeds correctly
   - CSV parsing uses `float()` appropriately
   - `format_rate_for_tc()` handles fractional formatting well
   - Most mathematical operations preserve float types

## Notes
- The Python team (Robert and Frank) maintains control over business logic
- Rust side focuses purely on efficient TC command execution
- This separation allows fast iteration on logic while gaining performance benefits